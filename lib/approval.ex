defmodule Approval do
  @moduledoc """
  Lightweight approval testing for Elixir

  This package provides some utilities to help automatically generate
  reference images for test cases, review those reference images
  and compare snapshots to the reference images to look for regressions.
  """

  alias Approval.ApprovalError

  require EEx
  require Logger

  @external_resource "priv/assets/resemble.js"
  @external_resource "priv/assets/diff.css"

  @diff_js File.read!("priv/assets/resemble.js")
  @diff_css File.read!("priv/assets/diff.css")

  EEx.function_from_file(:defp, :diff_html, "priv/assets/diff.html", [:assigns])

  @doc false
  def generate_diff_html(reference_path, snapshot_path, reference_data, snapshot_data) do
    diff_path = snapshot_path <> ".diff.html"

    html_file_content =
      diff_html(
        snapshot_path: snapshot_path,
        reference_path: reference_path,
        snapshot_data: Base.encode64(snapshot_data),
        reference_data: Base.encode64(reference_data),
        diff_js: @diff_js,
        diff_css: @diff_css
      )

    File.write!(diff_path, html_file_content)
  end

  defp approve_images(reference_path, snapshot_path, reviewed) do
    diff_path = reference_path <> ".diff.html"

    cond do
      # No snapshot file exists → Test fails
      not File.exists?(snapshot_path) ->
        raise ApprovalError,
              "Snapshot file \"#{Path.relative_to_cwd(snapshot_path)}\" does not exist."

      # First-time approval → Copy snapshot to reference and warn the user
      not File.exists?(reference_path) ->
        File.cp!(snapshot_path, reference_path)

        unless reviewed do
          Logger.warning(
            "\nThe following reference file must be reviewed: " <>
              "\"#{Path.relative_to_cwd(reference_path)}\""
          )
        end

      # Reference exists but has not been reviewed → Raise an error
      not reviewed ->
        raise ApprovalError,
              "The following reference has not been reviewed: " <>
                "\"#{Path.relative_to_cwd(reference_path)}\""

      # Both files exist and have been reviewed → Compare their contents
      true ->
        reference_content = File.read!(reference_path)
        snapshot_content = File.read!(snapshot_path)

        if reference_content == snapshot_content do
          # No differences → Remove any existing diff file
          if File.exists?(diff_path), do: File.rm!(diff_path)
        else
          Approval.generate_diff_html(
            reference_path,
            snapshot_path,
            reference_content,
            snapshot_content
          )

          raise ApprovalError, """
          The following reference and snapshot don't match:

                - #{Path.relative_to_cwd(reference_path)}
                - #{Path.relative_to_cwd(snapshot_path)}

              To see the differences, open the file "#{Path.relative_to_cwd(diff_path)}".
          """
        end
    end
  end

  @doc """
  Sets up an approval test.

  Takes the following arguments:

    - `:snapshot` - the data generated by your code.
      If the data represents an image, it should be given as
      `File.read!(some_path)`.

    - `:reference` - the reference data with which the snapshots
      will be compared. Again, if it represents an image, it should
      be given as `File.read!(some_path)`. This file doesn't need
      to exist. In fact, the whole point is that the `approval` macro
      will generate it the first time the test is run and you'll only
      have to review it later. If you already have a reference file,
      it won't be overwritten.

    - `:reviewed` (*optional*, default: `false`) - whether the reference
      data has been reviewed by the user or not

  #{File.read!("README.md") |> String.split("<!-- README SECTION -->") |> Enum.at(1)}
  """
  def approve(opts) do
    snapshot_path =
      case Keyword.fetch(opts, :snapshot) do
        {:ok, path} when is_binary(path) -> path
        _ -> raise ArgumentError, "approve/1 requires a valid :snapshot path"
      end

    reference_path =
      case Keyword.fetch(opts, :reference) do
        {:ok, path} when is_binary(path) -> path
        _ -> raise ArgumentError, "approve/1 requires a valid :reference path"
      end

    reviewed = Keyword.get(opts, :reviewed, false)

    approve_images(reference_path, snapshot_path, reviewed)
  end
end
